"""This module defines a parser for the logs generated by poker now."""

import logging
import re

from poker.model import actions
from poker.model import street
from poker.model import hand
from poker.model import game
from poker.model import player

ACTIONS = ["posts", "bets", "raises", "calls", "checks", "folds"]
FLOP_MARKER = "flop:"
TURN_MARKER = "turn:"
RIVER_MARKER = "river:"


def parse_game(game_data):
    """Parse a list of lines into a Game object."""

    logging.debug("Parsing Game")
    lines = game_data.split("\n")
    lines = list(reversed(lines))

    logging.debug("Getting hand ranges")
    hand_line_ranges = get_hand_index_ranges(lines)

    logging.debug("Parsing hands")
    hands = [parse_hand(get_hand(r, lines)) for r in hand_line_ranges]

    logging.debug("Parsing Game")
    return game.Game(hands=hands)


def get_hand_index_ranges(lines):
    """Return a list of hand start and end indicies"""

    hand_start_indices = []
    for i, line in enumerate(lines):
        if "-- starting hand #" in line:
            hand_start_indices.append(i)

    hand_end_indices = []
    for i, line in enumerate(lines):
        if "-- ending hand #" in line:
            hand_end_indices.append(i)

    return list(zip(hand_start_indices, hand_end_indices))


def get_hand(indices, game_lines):
    """Return a subset of the game between the supplied indices."""

    hand_start_index, hand_end_index = indices
    return game_lines[hand_start_index : hand_end_index + 1]


def parse_hand(hand_lines):

    i = 0
    while "Player stacks" not in hand_lines[i]:
        i += 1

    players = parse_players(hand_lines[i])
    i += 1

    our_cards = [
        c.strip()
        for c in sorted(
            hand_lines[i].split('"')[1].replace("Your hand is ", "").split(",")
        )
    ]
    i += 1

    preflop, i = parse_street(hand_lines, i, FLOP_MARKER)

    if FLOP_MARKER in hand_lines[i].lower():
        flop = parse_cards(hand_lines[i])
        i += 1
    else:
        logging.debug("No flop found on line %s", i)
        return hand.Hand(
            players=players,
            our_cards=our_cards,
            preflop=preflop,
            flop=None,
            first=None,
            turn=None,
            second=None,
            river=None,
            third=None,
        )

    first, i = parse_street(hand_lines, i, TURN_MARKER)

    if TURN_MARKER in hand_lines[i].lower():
        turn = parse_cards(hand_lines[i])
        i += 1
    else:
        logging.debug("No turn found on line %s", i)
        return hand.Hand(
            players=players,
            our_cards=our_cards,
            preflop=preflop,
            flop=flop,
            first=first,
            turn=None,
            second=None,
            river=None,
            third=None,
        )

    second, i = parse_street(hand_lines, i, RIVER_MARKER)

    if RIVER_MARKER in hand_lines[i].lower():
        river = parse_cards(hand_lines[i])
        i += 1
    else:
        logging.debug("No river found on line %s", i)
        return hand.Hand(
            players=players,
            our_cards=our_cards,
            preflop=preflop,
            flop=flop,
            first=first,
            turn=turn,
            second=second,
            river=None,
            third=None,
        )

    third, i = parse_street(hand_lines, i, "-- ending hand")
    return hand.Hand(
        players=players,
        our_cards=our_cards,
        preflop=preflop,
        flop=flop,
        first=first,
        turn=turn,
        second=second,
        river=river,
        third=third,
    )


def parse_cards(line):

    flop_cards = line[line.find("[") + 1 : line.rfind("]")]
    return flop_cards.split(",")


PLAYER_REGEX_STR = r'""([-_a-zA-Z0-9 ]+?) @ ([-_0-9a-zA-Z_]{10})""'
PLAYER_REGEX = re.compile(PLAYER_REGEX_STR)

PLAYER_STACK_REGEX = re.compile(
    f"#([1-9][0-9]*) {PLAYER_REGEX_STR} \\(([1-9][0-9]*)\\)"
)


def parse_players(line):
    """Parse the players from a hand."""

    players, _, _ = line.split(",")
    players = players[1:-1].replace("Player stacks: ", "")
    players = players.split("|")
    players = [player.strip() for player in players]

    player_objs = []
    for player_string in players:
        match = PLAYER_STACK_REGEX.search(player_string)
        if match is None:
            raise ValueError(f"Error parsing player string: {player_string}")

        player_objs.append(player.Player(name=match.group(2), id_=match.group(3)))

    return set(player_objs)


def parse_street(hand, i, term_keyword):
    """Parse a street of betting."""
    actions = []

    while True:
        line = hand[i]
        if "-- ending hand" in line or term_keyword in line.lower():
            break

        if is_action(line):
            action = parse_action(line)
            if action is None:
                print("error", i)

            actions.append(action)

        i += 1

    return street.Street(actions), i


ACTION_REGEX_STR = f'"{PLAYER_REGEX_STR} ({"|".join(ACTIONS)})( a (missed )?big blind of| a (missing )?small blind of| to)?( [1-9][0-9]*)?'
ACTION_REGEX = re.compile(ACTION_REGEX_STR)


def parse_action(line):
    """Parse the supplied line as a playe action"""

    action_string, _, _ = line.split(",")

    match = ACTION_REGEX.search(action_string)
    if match is None:
        raise ValueError(f"Could not parse action string: {action_string}")

    action_player = player.Player(name=match.group(1), id_=match.group(2))
    action = match.group(3)

    if action in ("bets", "posts", "raises", "calls"):
        if match.group(7) is None:
            raise ValueError(f"Couldn't parse actionWithAmount from: {action_string}")

        amount = int(match.group(7).strip())

        if "posts" in line:
            return actions.Post(player=action_player, amount=amount)

        if "bets" in line:
            return actions.Bet(player=action_player, amount=amount)

        if "raises" in line:
            return actions.Raise(player=action_player, amount=amount)

        if "calls" in line:
            return actions.Call(player=action_player, amount=amount)

    if "checks" in line:
        return actions.Check(player=action_player)

    if "folds" in line:
        return actions.Fold(player=action_player)

    raise ValueError("Error parsing line {line} as action")


def is_action(line: str) -> bool:
    """Return True if the line can be parsed as an action."""
    return ACTION_REGEX.match(line) is not None
