"""This module defines a parser for the logs generated by poker now."""

import logging
import re

from poker.model import actions
from poker.model import street
from poker.model import hand
from poker.model import game
from poker.model import player
from poker.model import card

ACTIONS = ["posts", "bets", "raises", "calls", "checks", "folds", "collected", "shows"]
FLOP_MARKER = "flop:"
TURN_MARKER = "turn:"
RIVER_MARKER = "river:"

STARTING_REGEX_STR = f'"-- starting hand #([1-9][0-9]*)'
STARTING_REGEX = re.compile(STARTING_REGEX_STR)

CARD_REGEX_STR = r"[AKQJ1-9]{1}0?[♥♣♠♦]"
CARD_REGEX = re.compile(CARD_REGEX_STR)

HAND_REGEX_STR = f'"Your hand is ({CARD_REGEX_STR}), ({CARD_REGEX_STR})".*'
HAND_REGEX = re.compile(HAND_REGEX_STR)

PLAYER_REGEX_STR = r'''""([-_a-zA-Z0-9' ]+?) @ ([-_0-9a-zA-Z_]{10})""'''
PLAYER_REGEX = re.compile(PLAYER_REGEX_STR)

PLAYER_STACK_REGEX = re.compile(
    f"#([1-9][0-9]*) {PLAYER_REGEX_STR} \\(([1-9][0-9]*)\\)"
)


ACTION_REGEX_STR = f'"{PLAYER_REGEX_STR} ({"|".join(ACTIONS)})( a (missed )?big blind of| a (missing )?small blind of| to| a straddle of| a ({CARD_REGEX_STR}), ({CARD_REGEX_STR}).)?( [0-9]+)?'
ACTION_REGEX = re.compile(ACTION_REGEX_STR)

UNCALLED_REGEX_STR = f"(Uncalled bet of)( [0-9]+)( returned to) {PLAYER_REGEX_STR}"
UNCALLED_REGEX = re.compile(UNCALLED_REGEX_STR)

SHOW_REGEX_STR = f'"{PLAYER_REGEX_STR} '


def parse_game(game_data):
    """Parse a list of lines into a Game object."""

    logging.debug("Parsing Game")
    lines = game_data.split("\n")
    lines = list(reversed(lines))

    logging.debug("Getting hand ranges")
    hand_line_ranges = get_hand_index_ranges(lines)

    logging.debug("Parsing hands")
    hands = []
    try:
        for r in hand_line_ranges:
            hands.append(parse_hand(get_hand(r, lines)))

        logging.debug("Parsing Game")
        return game.Game(hands=hands)

    except Exception as err:
        raise ValueError(f"Couldn't parse game hand in range: {r} error: {err}")


def get_hand_index_ranges(lines):
    """Return a list of hand start and end indicies"""

    hand_start_indices = []
    for i, line in enumerate(lines):
        if "-- starting hand #" in line:
            hand_start_indices.append(i)

    hand_end_indices = []
    for i, line in enumerate(lines):
        if "-- ending hand #" in line:
            hand_end_indices.append(i)

    return list(zip(hand_start_indices, hand_end_indices))


def get_hand(indices, game_lines):
    """Return a subset of the game between the supplied indices."""

    hand_start_index, hand_end_index = indices
    return game_lines[hand_start_index : hand_end_index + 1]


def parse_hand(hand_lines):

    # TODO filter out any lines that aren't part of the game `the player requested...` `the admin...`
    i = 0

    id = parse_starting_hand(hand_lines[i])

    while "Player stacks" not in hand_lines[i]:
        i += 1

    players, stacks = parse_players(hand_lines[i])
    i += 1

    our_cards = parse_our_cards(hand_lines[i])
    if our_cards is not None:
        i += 1

    preflop, i = parse_street(hand_lines, i, FLOP_MARKER)

    if FLOP_MARKER in hand_lines[i].lower():
        flop = parse_cards(hand_lines[i])
        i += 1
    else:
        logging.debug("No flop found on line %s", i)
        return hand.Hand(
            id=id,
            stacks=stacks,
            players=players,
            our_cards=our_cards,
            preflop=preflop,
            flop=None,
            first=None,
            turn=None,
            second=None,
            river=None,
            third=None,
        )

    first, i = parse_street(hand_lines, i, TURN_MARKER)

    if TURN_MARKER in hand_lines[i].lower():
        turn = parse_cards(hand_lines[i])
        i += 1
    else:
        logging.debug("No turn found on line %s", i)
        return hand.Hand(
            id=id,
            stacks=stacks,
            players=players,
            our_cards=our_cards,
            preflop=preflop,
            flop=flop,
            first=first,
            turn=None,
            second=None,
            river=None,
            third=None,
        )

    second, i = parse_street(hand_lines, i, RIVER_MARKER)

    if RIVER_MARKER in hand_lines[i].lower():
        river = parse_cards(hand_lines[i])
        i += 1
    else:
        logging.debug("No river found on line %s", i)
        return hand.Hand(
            id=id,
            stacks=stacks,
            players=players,
            our_cards=our_cards,
            preflop=preflop,
            flop=flop,
            first=first,
            turn=turn,
            second=second,
            river=None,
            third=None,
        )

    third, i = parse_street(hand_lines, i, "-- ending hand")
    return hand.Hand(
        id=id,
        stacks=stacks,
        players=players,
        our_cards=our_cards,
        preflop=preflop,
        flop=flop,
        first=first,
        turn=turn,
        second=second,
        river=river,
        third=third,
    )


def parse_starting_hand(line):
    line, _, _ = line.rsplit(",")
    match = STARTING_REGEX.match(line)

    if match == None:
        raise ValueError(f"Could not parse starting hand line from: {line}")

    return int(match.group(1))


def parse_our_cards(line):

    match = HAND_REGEX.match(line)

    if match is None:
        return None

    return (
        card.Card.from_string(match.group(1)),
        card.Card.from_string(match.group(2)),
    )


def parse_cards(line):

    cards = line[line.find("[") + 1 : line.rfind("]")]
    return [card.Card.from_string(c.strip()) for c in cards.split(",")]


def parse_players(line):
    """Parse the players from a hand."""

    players, _, _ = line.split(",")
    players = players[1:-1].replace("Player stacks: ", "")
    players = players.split("|")
    players = [player.strip() for player in players]

    player_objs = []
    stacks = []

    for player_string in players:
        match = PLAYER_STACK_REGEX.search(player_string)
        if match is None:
            raise ValueError(f"Error parsing player string: {player_string}")

        player_obj = player.Player(name=match.group(2), id_=match.group(3))

        player_objs.append(player_obj)
        stacks.append((player_obj, int(match.group(4))))

    return set(player_objs), stacks


def parse_street(hand, i, term_keyword):
    """Parse a street of betting."""
    actions = []

    while True:
        line = hand[i]
        if "-- ending hand" in line or term_keyword in line.lower():
            break

        if is_action(line):
            action = parse_action(line)
            if action is None:
                print("error", i)

            actions.append(action)

        i += 1

    return street.Street(actions), i


def parse_action(line):
    """Parse the supplied line as a player action"""

    action_string, _, _ = line.rsplit(",", 2)

    if "Uncalled" in line:
        match = UNCALLED_REGEX.search(action_string)
        if match == None:
            raise ValueError(
                f"Could not parse action string: {action_string} as return action"
            )

        action_player = player.Player(name=match.group(4), id_=(match.group(5)))
        amount = int(match.group(2).strip())
        return actions.Return(player=action_player, amount=amount)

    match = ACTION_REGEX.search(action_string)
    if match is None:
        raise ValueError(f"Could not parse action string: {action_string}")

    action = match.group(3)

    if action in (
        "bets",
        "posts",
        "raises",
        "calls",
        "collected",
        "checks",
        "folds",
        "shows",
    ):
        action_player = player.Player(name=match.group(1), id_=match.group(2))

        if "checks" in line:
            return actions.Check(player=action_player)

        if "folds" in line:
            return actions.Fold(player=action_player)

        if "shows" in line:
            if (match.group(7) or match.group(8)) is None:
                raise ValueError(
                    f"Couldn't parse actionWithCards from: {action_string} considered as {action}"
                )

            cards = (
                card.Card.from_string(match.group(7)),
                card.Card.from_string(match.group(8)),
            )
            return actions.Show(player=action_player, cards=cards)

        if match.group(9) is None:
            raise ValueError(
                f"Couldn't parse actionWithAmount from: {action_string} considered as {action}"
            )

        amount = int(match.group(9).strip())

        if "posts" in line:
            return actions.Post(player=action_player, amount=amount)

        if "bets" in line:
            return actions.Bet(player=action_player, amount=amount)

        if "raises" in line:
            return actions.Raise(player=action_player, amount=amount)

        if "calls" in line:
            return actions.Call(player=action_player, amount=amount)

        if "collected" in line:
            return actions.Collect(player=action_player, amount=amount)

    raise ValueError(f"Error parsing line {line} as {action}")


def is_action(line: str) -> bool:
    """Return True if the line can be parsed as an action."""
    return ACTION_REGEX.match(line) is not None
